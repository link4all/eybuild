<html>
<head>
<!-- E:/eybuild/doc/export//ebio.html - generated by refgen from ebio.c -->
 <title> ebio </title>
</head>
<body bgcolor="#FFFFFF"> <hr>

<a name="top"></a>
<p align=right>
<a href="libIndex.htm"><i>eyBuildLib API Reference :  eyBuildLib</i></a></p>

</blockquote><h1>ebio</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebio</strong> - a high efficiency I/O buffer for CSP </p>


</blockquote><h4>ROUTINES</h4><blockquote><p>
<p>
<b><a href="./ebio.html#ebHeader">ebHeader</a>(&nbsp;)</b>  -  output HTTP header<br>
<b><a href="./ebio.html#ebRedirect">ebRedirect</a>(&nbsp;)</b>  -  redirect to an url<br>
<b><a href="./ebio.html#ebUrlEncode">ebUrlEncode</a>(&nbsp;)</b>  -  encode the URL and store in a global buffer<br>
<b><a href="./ebio.html#ebUrlDecode">ebUrlDecode</a>(&nbsp;)</b>  -  decode the URL and store in a global buffer<br>
<b><a href="./ebio.html#ebEvaluate">ebEvaluate</a>(&nbsp;)</b>  -  evaluate pdata and then output to buffer<br>
<b><a href="./ebio.html#ebBufReset">ebBufReset</a>(&nbsp;)</b>  -  reset the state to initialization state<br>
<b><a href="./ebio.html#ebBufCreate">ebBufCreate</a>(&nbsp;)</b>  -  allocate a new tlv buffer then init it<br>
<b><a href="./ebio.html#ebBufDistroy">ebBufDistroy</a>(&nbsp;)</b>  -  free eybuild buffer<br>
<b><a href="./ebio.html#ebBufResize">ebBufResize</a>(&nbsp;)</b>  -  change tlv buffer size to new size<br>
<b><a href="./ebio.html#ebBufIsAutoFlush">ebBufIsAutoFlush</a>(&nbsp;)</b>  -  check allow auto flush or not<br>
<b><a href="./ebio.html#ebSetBufAutoFlush">ebSetBufAutoFlush</a>(&nbsp;)</b>  -  set allow auto flush or not<br>
<b><a href="./ebio.html#ebGetBufRemain">ebGetBufRemain</a>(&nbsp;)</b>  -  get the remain size for data write to avaiable<br>
<b><a href="./ebio.html#ebBufFlush">ebBufFlush</a>(&nbsp;)</b>  -  flush eybuild buffer<br>
<b><a href="./ebio.html#ebCheckBufSize">ebCheckBufSize</a>(&nbsp;)</b>  -  check tlv buffer size<br>
<b><a href="./ebio.html#ebBufStringAdd">ebBufStringAdd</a>(&nbsp;)</b>  -  add a const string to the eybuild buffer<br>
<b><a href="./ebio.html#ebprintf">ebprintf</a>(&nbsp;)</b>  -  write a formatted string to the eybuild buffer<br>
<p>
</blockquote><h4>DESCRIPTION</h4><blockquote><p>
This module provided a high efficiency I/O buffer. It will be used by 
CSP page to buffering data, which is outputed by <b><a href="./ebio.html#ebprintf">ebprintf</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebEvaluate">ebEvaluate</a>(&nbsp;)</b>
<b><a href="./ebio.html#ebBufStringAdd">ebBufStringAdd</a>(&nbsp;)</b>.
<p>
User can call <b><a href="./ebio.html#ebBufIsAutoFlush">ebBufIsAutoFlush</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebGetBufRemain">ebGetBufRemain</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebCheckBufSize">ebCheckBufSize</a>(&nbsp;)</b> to get 
current buffer properties; User can call <b><a href="./ebio.html#ebBufResize">ebBufResize</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebSetBufAutoFlush">ebSetBufAutoFlush</a>(&nbsp;)</b>, 
<b><a href="./ebio.html#ebBufFlush">ebBufFlush</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebBufReset">ebBufReset</a>(&nbsp;)</b> to set buffer properties; User can call <b><a href="./ebio.html#ebprintf">ebprintf</a>(&nbsp;)</b>, 
<b><a href="./ebio.html#ebBufStringAdd">ebBufStringAdd</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebEvaluate">ebEvaluate</a>(&nbsp;)</b> add data to buffer.
<p>
When you call <b><a href="./ebio.html#ebHeader">ebHeader</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebRedirect">ebRedirect</a>(&nbsp;)</b>, it will check the buffer state. 
If has data flushed before, they will return ERROR. Because those data 
should be output before CSP page data output.
<p>
Usually user needn't call <b><a href="./ebio.html#ebBufCreate">ebBufCreate</a>(&nbsp;)</b>, <b><a href="./ebio.html#ebBufDistroy">ebBufDistroy</a>(&nbsp;)</b> to create and 
distory a CSP page buffer.
<p>
</blockquote><h4>ALSO SEE</h4><blockquote><p>
<p>
<b>snprintf(&nbsp;)</b>
<p>

<hr>
<a name="ebHeader"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebHeader(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebHeader(&nbsp;)</strong> - output HTTP header</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebHeader
    (
    void *       ebfp,
    const char * fmt,         /* format string to write */
                 ...          /* optional arguments to format string */
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine is to  output HTTP header. if data has been flushed before,
it will not output this header and will return ERROR. 
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebRedirect"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebRedirect(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebRedirect(&nbsp;)</strong> - redirect to an url</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebRedirect
    (
    void * ebfp,
    char * p_url
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine is to redirect to an url. if data has been flushed before,
it will not redirect to the url and return will ERROR.
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebUrlEncode"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebUrlEncode(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebUrlEncode(&nbsp;)</strong> - encode the URL and store in a global buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>char * ebUrlEncode
    (
    char * url                /* src url */
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine is to encode the URL and store in a global buffer. 
The value will be covered when next time call <b><a href="./ebio.html#ebUrlEncode">ebUrlEncode</a>(&nbsp;)</b> or <b><a href="./ebio.html#ebUrlDecode">ebUrlDecode</a>(&nbsp;)</b>.
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebUrlDecode"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebUrlDecode(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebUrlDecode(&nbsp;)</strong> - decode the URL and store in a global buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>char * ebUrlDecode
    (
    const char * url          /* src url */
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine is to decode the URL and store in a global buffer. 
The value will be covered when next time call <b><a href="./ebio.html#ebUrlEncode">ebUrlEncode</a>(&nbsp;)</b> or <b><a href="./ebio.html#ebUrlDecode">ebUrlDecode</a>(&nbsp;)</b>.
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebEvaluate"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebEvaluate(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebEvaluate(&nbsp;)</strong> - evaluate pdata and then output to buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>#if 0 int ebEvaluate
    (
    void * ebfp,
    char * pdata,
           ...
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine evaluate pdata and then output to buffer
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
length of output, otherwize ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufReset"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufReset(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufReset(&nbsp;)</strong> - reset the state to initialization state</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebBufReset
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufCreate"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufCreate(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufCreate(&nbsp;)</strong> - allocate a new tlv buffer then init it</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>void * ebBufCreate
    (
    int size
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
</blockquote><h4>RETURNS</h4><blockquote><p>
the descriptor of new this new buffer, or NULL if error
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufDistroy"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufDistroy(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufDistroy(&nbsp;)</strong> - free eybuild buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>void ebBufDistroy
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine will not auto flush data in buffer, so before call 
function you shoud call <b><a href="./ebio.html#ebBufFlush">ebBufFlush</a>(&nbsp;)</b> manually to flush data. 
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
NONE
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufResize"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufResize(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufResize(&nbsp;)</strong> - change tlv buffer size to new size</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebBufResize
    (
    void * ebfp,
    int    size
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine will not flush the original data, but copy to the new buffer
if no enough dynamic memory will return ERROR
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufIsAutoFlush"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufIsAutoFlush(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufIsAutoFlush(&nbsp;)</strong> - check allow auto flush or not</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebBufIsAutoFlush
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
</blockquote><h4>RETURNS</h4><blockquote><p>
TRUE/FALSE
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebSetBufAutoFlush"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebSetBufAutoFlush(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebSetBufAutoFlush(&nbsp;)</strong> - set allow auto flush or not</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebSetBufAutoFlush
    (
    void * ebfp,              /* eybuild buffer descriptor */
    BOOL   autoflush
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
set allow auto flush or not 
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
TRUE/FALSE
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebGetBufRemain"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebGetBufRemain(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebGetBufRemain(&nbsp;)</strong> - get the remain size for data write to avaiable</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebGetBufRemain
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
get the remain size for data write to avaiable
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
the size write avaiable, or <= 0 if buffer size not enough
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufFlush"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufFlush(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufFlush(&nbsp;)</strong> - flush eybuild buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebBufFlush
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
This routine writes data in eybuild buffer to stdout
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebCheckBufSize"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebCheckBufSize(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebCheckBufSize(&nbsp;)</strong> - check tlv buffer size</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebCheckBufSize
    (
    void * ebfp
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
if buffer is full, it will try to flush it and the retry check once
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
size avaiable write to, or ERROR when flush buffer error
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebBufStringAdd"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebBufStringAdd(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebBufStringAdd(&nbsp;)</strong> - add a const string to the eybuild buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebBufStringAdd
    (
    void * ebfp,              /* eybuild buffer descriptor */
    char * pstr               /* const string */
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
this routine let the value pointer of tlv pointer to that const string,
but will not free it if is allocated by <b>malloc(&nbsp;)</b>, <b>alloc(&nbsp;)</b>, <b>realloc(&nbsp;)</b>,
so the area parameter <b>pstr</b> pointer to should better be a const string.
<p>
After call <b><a href="./ebio.html#ebBufFlush">ebBufFlush</a>(&nbsp;)</b>, that tlv will be set to zero.
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
OK/ERROR
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>

<hr>
<a name="ebprintf"></a>
<p align=right>
<a href="rtnIndex.htm"><i>eyBuildLib :  Routines</i></a></p>

</blockquote><h1>ebprintf(&nbsp;)</h1> <blockquote></a></blockquote><h4>NAME</h4><blockquote>  
<p><strong>ebprintf(&nbsp;)</strong> - write a formatted string to the eybuild buffer</p>

</blockquote><h4>SYNOPSIS</h4><blockquote><p>
<pre>int ebprintf
    (
    void *       ebfp,        /* eybuild buffer descriptor */
    const char * fmt,         /* format string to write */
                 ...          /* optional arguments to format string */
    )
</pre>

</blockquote><h4>DESCRIPTION</h4><blockquote><p>
This routine writes a formatted string to a specified file descriptor. 
Its function and syntax are otherwise identical to printf( ). 
<p>
</blockquote><h4>RETURNS</h4><blockquote><p>
<p>
The number of characters output, or ERROR if there is an error during output.
<p>
</blockquote><h4>SEE ALSO</h4><blockquote><p>
<b><a href="./ebio.html#top">ebio</a></b>, <b>printf(&nbsp;)</b>, <b>fprintf(&nbsp;)</b>

</body>
</html>



